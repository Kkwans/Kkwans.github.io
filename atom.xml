<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-03-13T05:54:49.035Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Kkwans</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AOP的的实现方式——动态代理</title>
    <link href="http://example.com/post/ab428168.html"/>
    <id>http://example.com/post/ab428168.html</id>
    <published>2024-02-15T07:32:16.000Z</published>
    <updated>2024-03-13T05:54:49.035Z</updated>
    
    <content type="html"><![CDATA[<p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在提高代码的模块化程度。AOP通过将横切关注点（如日志、事务管理等）从业务逻辑代码中分离出来，来提高代码的可维护性和复用性。在Java中，AOP通常是通过动态代理来实现的。动态代理主要有两种实现方式：基于接口的JDK动态代理和基于类的CGLIB动态代理。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是通过实现接口的方式来创建代理对象的。其原理是在运行时动态地在内存中构建代理对象，并实现指定的接口。使用<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口来创建代理对象和自定义方法调用的处理逻辑。</p><ul><li><p><strong>实现步骤</strong>：</p><ol><li>创建一个实现<code>InvocationHandler</code>接口的处理器类，重写<code>invoke</code>方法，定义代理对象调用方法时的行为。</li><li>使用<code>Proxy.newProxyInstance</code>方法，传入类加载器、接口数组和上一步创建的调用处理器，动态创建代理对象。</li></ol></li><li><p><strong>示例代码</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args); <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="comment">// 在目标方法执行后可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">    MyInterface.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;MyInterface.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>())</span><br><span class="line">);</span><br><span class="line">proxy.someMethod();</span><br></pre></td></tr></table></figure><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB（Code Generation Library）是一个第三方代码生成库，它允许在运行时动态生成新的类。CGLIB动态代理不需要基于接口，它是通过继承目标类并重写其方法来实现代理的。</p><ul><li><p><strong>实现步骤</strong>：</p><ol><li>创建一个继承<code>MethodInterceptor</code>接口的拦截器类，并重写<code>intercept</code>方法，定义方法调用的拦截逻辑。</li><li>使用<code>Enhancer</code>类创建代理对象，设置父类为目标类，并设置回调拦截器。</li></ol></li><li><p><strong>示例代码</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args); <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="comment">// 在目标方法执行后可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(MyClass.class); <span class="comment">// 设置父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>()); <span class="comment">// 设置方法拦截器</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyClass) enhancer.create();</span><br><span class="line">proxy.someMethod();</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AOP利用动态代理技术在运行时对方法调用进行拦截和增强，实现了横切关注点与业务逻辑的分离。JDK动态代理和CGLIB代理是实现动态代理的两种主要方式，前者依赖接口，后者可以直接代理类。在Spring框架中，根据目标对象是否实现了接口，自动选择使用JDK动态代理还是CGLIB代理来实现AOP。</p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="JDK动态代理-1"><a href="#JDK动态代理-1" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK动态代理是Java中一种基于接口的动态代理技术。它允许在运行时动态地创建一个代理对象，这个代理对象可以实现目标对象所实现的接口。JDK动态代理通过反射机制实现，它要求目标对象必须实现一个或多个接口。在代理对象中，开发者可以实现横切逻辑，从而在方法执行前后添加额外的功能。</p><p>以下是使用JDK动态代理的一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  目标类，实现了接口</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">interface</span>  <span class="title class_">MyInterface</span>  &#123;</span><br><span class="line">     <span class="keyword">void</span>  <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">MyClass</span>  <span class="keyword">implements</span>  <span class="title class_">MyInterface</span>  &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">doSomething</span><span class="params">()</span>  &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;执行目标方法&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  代理类，实现了InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">MyInvocationHandler</span>  <span class="keyword">implements</span>  <span class="title class_">InvocationHandler</span>  &#123;</span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">final</span>  Object  target;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span>  <span class="title function_">MyInvocationHandler</span><span class="params">(Object  target)</span>  &#123;</span><br><span class="line">          <span class="built_in">this</span>.target  =  target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span>  Object  <span class="title function_">invoke</span><span class="params">(Object  proxy,  Method  method,  Object[]  args)</span>  <span class="keyword">throws</span>  Throwable  &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;执行横切逻辑...&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>  method.invoke(target,  args);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span>  &#123;</span><br><span class="line">         <span class="comment">//  创建目标对象</span></span><br><span class="line">         <span class="type">MyClass</span>  <span class="variable">myClass</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//  创建代理对象</span></span><br><span class="line">         <span class="type">MyInterface</span>  <span class="variable">myInterface</span>  <span class="operator">=</span>  (MyInterface)  Proxy.newProxyInstance(</span><br><span class="line">                 myClass.getClass().getClassLoader(),  <span class="comment">//  类加载器</span></span><br><span class="line">                 myClass.getClass().getInterfaces(),  <span class="comment">//  目标对象实现的接口</span></span><br><span class="line">                 <span class="keyword">new</span>  <span class="title class_">MyInvocationHandler</span>(myClass)  <span class="comment">//  方法调用的处理器</span></span><br><span class="line">         );</span><br><span class="line"></span><br><span class="line">         <span class="comment">//  通过代理对象调用目标方法</span></span><br><span class="line">         myInterface.doSomething();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>MyClass</code>实现了<code>MyInterface</code>接口，<code>MyInvocationHandler</code>实现了<code>InvocationHandler</code>接口。通过<code>Proxy.newProxyInstance()</code>方法创建代理对象，将<code>MyClass</code>作为目标对象传递给这个方法。在<code>MyInvocationHandler</code>的<code>invoke()</code>方法中，可以添加横切逻辑，例如日志记录、事务管理等。最后，通过代理对象<code>myInterface</code>调用目标方法<code>doSomhing()</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在提高代码的模块化程度。AOP通过将横切关注点（如日志、事务管理等）从业务逻辑代码中分离出来，来提高代码的可维护性和复用性。在Java中，AOP通常是通过动态代理来实现的。动态代</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Spring" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/Spring/"/>
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="AOP" scheme="http://example.com/tags/AOP/"/>
    
    <category term="动态代理" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JUC的核心——AQS</title>
    <link href="http://example.com/post/f3171170.html"/>
    <id>http://example.com/post/f3171170.html</id>
    <published>2024-02-13T01:25:38.000Z</published>
    <updated>2024-03-13T05:54:49.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS(AbstractQueuedSynchronizer)是一个多线程同步器，它是JUC并发包中多个组件的底层实现，比如ReentrantLock、CountDownLatch、Semaphore等都是通过ASQ实现的。</p><p>AQS提供了两种锁的机制，分别是排它锁（独占模式）和共享锁（共享模式）</p><ul><li><strong>排它锁</strong>存在多个线程竞争锁资源，同一时刻只允许一个线程访问共享资源,<code>ReentrantLock</code>就是通过AQS的独占模式实现排他锁</li><li><strong>共享锁</strong>类似于读锁,在同一时刻运行多个线程获取共享资源，<code>CountDownLatch</code>、<code>Semaphore</code>都用到了共享锁的实现</li></ul><p>ASQ 内部维护了一个<code>int</code>变量<code>state</code>(volatile修饰）用来记录锁竞争时的状态，<br>在独占模式下，当有线程想要获取锁资源，需要先判断state==0，如果等于0表示无锁状态，将其更新为1表示该线程独占了锁资源，<br>在多线程情况下这种操作可能造成线程安全问题，因此需要通过<code>CAS</code>更新<code>state</code>状态保证<code>线程安全</code></p><p>未竞争到锁的线程会调用<code>Unsafe</code>类中的<code>park</code>方法进行阻塞，然后将阻塞的线程 按照<code>先进先出</code>原则放入AQS内维护的<strong>双向链表</strong><code>等待队列</code>（又称阻塞队列、同步队列，借鉴<code>CHL</code>锁实现。类似于 Monitor 的 EntryList，插入前将该线程包装成一个 Node 节点，然后将其插入队列的尾部。）<br>当持有锁的线程释放锁时，AQS会将等待队列中的第一个线程唤醒，并让其重新尝试获取锁</p><p>AQS可以实现公平锁和非公平锁，其区别体现在：<br>有新的线程竞争锁时，公平锁需要先判断等待队列中是否有阻塞的队列，若有，则需要排队等待<br>而非公平锁不管在其之前是否有等待阻塞的线程，都会直接参与锁的竞争而不用先排队</p><p>以上是我对AQS的一点理解</p><hr><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>AQS中还有一个条件变量<code>ConditionObject</code> 类似于 Monitor 的 <code>WaitSet</code></p><p>ConditionObject是AQS的一个内部类，用于实现条件变量。条件变量是并发编程中一种用于线程间通信的机制，它允许一个或多个线程在特定条件成立之前等待，同时释放相关的锁。这在某种程度上类似于对象监视器模式中的wait()和notify()方法，但提供了更灵活和更强大的控制。</p><p>条件队列与同步队列不同，它是基于Condition接口实现的，用于管理那些因为某些条件未满足而等待的线程。当条件满足时，这些线程可以被唤醒。每个Condition对象都有自己的一个条件队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 条件队列的首尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当线程调用了Condition的await()方法后，它会释放当前持有的锁，并且该线程会被加入到条件队列中等待，直到被另一个线程的signal()或signalAll()方法唤醒，或被中断。</li><li>signal()：唤醒等待队列中的头节点对应的线程。<br>  signalAll()：唤醒所有等待的线程。</li></ul><blockquote><p>条件队列和同步队列，主要有以下区别：</p><ul><li><strong>目的不同</strong>：同步队列主要用于管理锁的获取和释放，而条件队列用于等待特定条件的满足。</li><li><strong>使用方式不同</strong>：同步队列是AQS自动管理的，开发者通常不需要直接与之交互；而条件队列是通过Condition接口暴露给开发者的，需要显式地调用等待（await）和通知（signal/signalAll）方法。</li><li><strong>队列类型不同</strong>：虽然它们都是队列结构，但同步队列是所有基于AQS同步器共享的，每个同步器实例只有一个同步队列；条件队列是每个Condition实例特有的，一个同步器可以有多个Condition对象，因此也就有多个条件队列。</li></ul></blockquote><h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p>CLH（Craig, Landin, and Hagersten）锁是一种基于链表的可扩展、高性能、公平的自旋锁，广泛应用于实现锁机制。CLH锁的主要思想是将锁的拥有者和等待者分离，锁状态不再保存在锁对象本身，而是保存在线程（或CPU）的本地变量中。这种设计减少了锁的竞争，使得锁的获取更加高效，同时也保证了公平性。</p><h4 id="CLH锁的基本结构"><a href="#CLH锁的基本结构" class="headerlink" title="CLH锁的基本结构"></a>CLH锁的基本结构</h4><p>CLH锁使用一个隐式的链表来维护锁的等待队列。每个节点（通常代表一个线程）包含一个标志位，表示该线程是否在等待锁。节点被组织成一个FIFO（先进先出）队列，确保了锁的公平性。</p><h4 id="CLH锁的工作原理"><a href="#CLH锁的工作原理" class="headerlink" title="CLH锁的工作原理"></a>CLH锁的工作原理</h4><ol><li><p><strong>锁获取</strong>：当一个线程尝试获取锁时，它会创建一个新的队列节点，并将其自己的节点设置为“锁定”状态。然后，它将自己的节点插入到队列的末尾，并检查前一个节点的状态：</p><ul><li>如果前一个节点的状态是“未锁定”，则当前线程可以获取锁并进入临界区。</li><li>如果前一个节点的状态是“锁定”，则当前线程需要自旋等待，直到前一个节点释放锁（即前一个节点的状态变为“未锁定”）。</li></ul></li><li><p><strong>锁释放</strong>：当一个线程完成其临界区的执行并准备释放锁时，它只需要将其节点的状态设置为“未锁定”。这会让后续的节点（如果有的话）注意到锁已经被释放，从而尝试获取锁。</p></li></ol><h4 id="CLH锁的优点"><a href="#CLH锁的优点" class="headerlink" title="CLH锁的优点"></a>CLH锁的优点</h4><ul><li><strong>高效的锁获取和释放</strong>：由于锁的状态保存在本地变量中，线程获取和释放锁时减少了对共享变量的访问，降低了系统的总体开销。</li><li><strong>公平性</strong>：CLH锁通过FIFO队列确保了每个线程都能按照请求锁的顺序获得锁，避免了“饥饿”现象。</li><li><strong>可扩展性</strong>：CLH锁的设计减少了锁的争用，使得它在多处理器系统中表现出良好的扩展性。</li></ul><h4 id="CLH锁的应用"><a href="#CLH锁的应用" class="headerlink" title="CLH锁的应用"></a>CLH锁的应用</h4><p>CLH锁因其高效和公平的特性，被广泛应用于实现各种并发数据结构和同步机制，特别是在多处理器系统中。Java的<code>java.util.concurrent.locks</code>包中的<code>ReentrantLock</code>在其公平模式下内部使用了类似CLH锁的变种来实现锁的管理。</p><h4 id="CLH队列和AQS的关系"><a href="#CLH队列和AQS的关系" class="headerlink" title="CLH队列和AQS的关系"></a>CLH队列和AQS的关系</h4><ol><li><strong>设计思想上的继承</strong>：AQS在设计上借鉴了CLH队列锁的思想，特别是在管理等待线程方面。AQS中的等待队列虽然是显式的（每个节点都是显式创建的），但其公平性和FIFO的特性与CLH队列锁相似。</li><li><strong>自旋的应用</strong>：虽然AQS不直接使用CLH锁的自旋机制，但它提供了基础设施，允许构建在其上的同步器根据需要实现自旋等待，这在某种程度上反映了CLH锁设计的影响。</li><li><strong>节点的状态管理</strong>：AQS中的每个节点代表一个等待获取锁的线程，这与CLH队列中每个节点代表一个等待状态的线程的概念相似。AQS通过状态变量和队列节点的管理实现了复杂的同步语义，而CLH锁则更专注于实现高效的自旋锁。</li><li><strong>锁的公平性</strong>：AQS支持创建公平锁和非公平锁，其中公平锁的实现保证了按照请求锁的顺序来获取锁，这与CLH队列锁的公平性原则相吻合。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h2&gt;&lt;p&gt;AQS(AbstractQueuedSynchronizer)是一个多线程同步器，它是JUC并发包中多个组件的底层实现，比如Reen</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="JUC" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/JUC/"/>
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
    <category term="AQS" scheme="http://example.com/tags/AQS/"/>
    
    <category term="CLH" scheme="http://example.com/tags/CLH/"/>
    
  </entry>
  
  <entry>
    <title>如何保证线程执行顺序？</title>
    <link href="http://example.com/post/9e10e520.html"/>
    <id>http://example.com/post/9e10e520.html</id>
    <published>2024-02-11T11:03:53.000Z</published>
    <updated>2024-03-13T03:18:03.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h2><h3 id="1-使用join-方法"><a href="#1-使用join-方法" class="headerlink" title="1. 使用join()方法"></a>1. 使用<code>join()</code>方法</h3><p>这是最简单直接的方法，通过调用前一个线程的<code>join()</code>方法，可以让当前线程等待直到前一个线程结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;T1运行&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用CountDownLatch"><a href="#2-使用CountDownLatch" class="headerlink" title="2. 使用CountDownLatch"></a>2. 使用<code>CountDownLatch</code></h3><p><code>CountDownLatch</code>是一种同步辅助工具，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1运行&quot;</span>);</span><br><span class="line">            latch1.countDown(); <span class="comment">// 减少计数</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latch1.await(); <span class="comment">// 等待latch1归零</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">                latch2.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latch2.await(); <span class="comment">// 等待latch2归零</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用CyclicBarrier"><a href="#3-使用CyclicBarrier" class="headerlink" title="3. 使用CyclicBarrier"></a>3. 使用<code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code>是一种同步辅助工具，它允许一组线程相互等待，达到一个公共屏障点(common barrier point)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1运行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// doing someting...</span></span><br><span class="line">                barrier1.await(); <span class="comment">// 等待T2准备就绪</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier1.await(); <span class="comment">// 确保T1已运行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">                barrier2.await(); <span class="comment">// 等待T3准备就绪</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier2.await(); <span class="comment">// 确保T2已运行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用Semaphore"><a href="#4-使用Semaphore" class="headerlink" title="4. 使用Semaphore"></a>4. 使用<code>Semaphore</code></h3><p><code>Semaphore</code>是一种基于计数的信号量。它可以设置信号量的初始值，用于多线程间的协调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">sem1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">sem2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1运行&quot;</span>);</span><br><span class="line">            sem1.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sem1.acquire(); <span class="comment">// 请求一个许可</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">                sem2.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sem2.acquire(); <span class="comment">// 请求一个许可</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h2><p>首先，我们需要了解线程是并发执行的，所以默认情况下它们的执行顺序是不确定的。但是，有时我们需要它们按照特定的顺序来执行。为了实现这一点，我们可以使用几种同步机制：</p><ol><li><p><strong>使用<code>join()</code>方法</strong>：这是最直接的方法。当我们想要确保当前线程在另一个线程<code>T</code>完成之后再执行时，我们可以在当前线程中调用<code>T.join()</code>。这会让当前线程等待，直到线程<code>T</code>执行完毕。这种方法简单易用，但是它不够灵活，因为它要求线程严格地一个接一个地执行。</p></li><li><p><strong>使用<code>CountDownLatch</code></strong>：这是一个高级的同步辅助类。它允许一个或多个线程等待一系列其他线程完成执行。我们可以给<code>CountDownLatch</code>一个初始的计数值，每当一个线程完成了它的任务，它就调用<code>countDown()</code>方法。其他线程可以通过调用<code>await()</code>方法来等待计数器达到零。这种方法比<code>join()</code>更灵活，因为它允许多个线程等待其他线程的操作。</p></li><li><p><strong>使用<code>CyclicBarrier</code></strong>：这个同步辅助类允许一组线程互相等待，直到所有线程都达到了一个公共的屏障点。与<code>CountDownLatch</code>不同的是，<code>CyclicBarrier</code>是可以重用的。这对于需要所有线程在继续执行前达到某个公共点的情况很有用。</p></li><li><p><strong>使用<code>Semaphore</code></strong>：这是一个基于计数的同步机制。我们可以初始化一个<code>Semaphore</code>并给它一个许可的数量。线程可以通过<code>acquire()</code>方法获取许可，如果没有可用的许可，线程将等待。一旦线程执行完毕，它可以通过<code>release()</code>方法释放许可。通过控制许可的分配，我们可以控制线程的执行顺序。</p></li></ol><p>在实际的应用中，选择哪种同步机制取决于我们的具体需求。例如，如果我们只是想让线程顺序执行并且不会再次使用这些线程，<code>join()</code>可能是最简单的方法。但如果我们需要更复杂的同步，比如允许一组线程等待另一组线程完成，或者需要一个可以重用的同步点，那么<code>CountDownLatch</code>和<code>CyclicBarrier</code>可能更加合适。如果我们需要控制对某些资源的并发访问，<code>Semaphore</code>可能是最好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？&quot;&gt;&lt;a href=&quot;#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？&quot; class=&quot;headerlink&quot; title=&quot;新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="JUC" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/JUC/"/>
    
    
    <category term="八股" scheme="http://example.com/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="多线程" scheme="http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="同步" scheme="http://example.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
</feed>

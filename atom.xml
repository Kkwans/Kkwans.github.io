<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>K&#39;Blog</title>
  
  
  <link href="https://kkwans.cn/atom.xml" rel="self"/>
  
  <link href="https://kkwans.cn/"/>
  <updated>2024-03-23T10:14:51.597Z</updated>
  <id>https://kkwans.cn/</id>
  
  <author>
    <name>Kkwans</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何保证Redis缓存与数据库的双写一致性？</title>
    <link href="https://kkwans.cn/post/895d22a5.html"/>
    <id>https://kkwans.cn/post/895d22a5.html</id>
    <published>2024-03-08T12:20:16.000Z</published>
    <updated>2024-03-23T10:14:51.597Z</updated>
    
    <content type="html"><![CDATA[<p>在分布式系统中，双写一致性问题是指当系统同时对缓存（如 Redis）和数据库（如 MySQL）进行写操作时，如何保证这两个数据存储之间数据的一致性。这是一个非常常见但又难以解决的问题，因为缓存系统和数据库系统通常是独立运行的，它们之间无法自动同步数据变更，从而可能导致数据不一致的情况发生。</p><h2 id="先更新数据库还是先删除缓存？"><a href="#先更新数据库还是先删除缓存？" class="headerlink" title="先更新数据库还是先删除缓存？"></a>先更新数据库还是先删除缓存？</h2><h3 id="先删缓存"><a href="#先删缓存" class="headerlink" title="先删缓存"></a>先删缓存</h3><p>如果先删除缓存，再更新数据库，会出现数据不一致的情况，</p><p>因为<strong>数据库的更新操作比较慢</strong>，在<code>删除缓存</code>和<code>更新完数据库</code>之间，可能有其他线程从数据库中<code>读取旧的数据并写入缓存</code>，如图：</p><p><img src="/images/image-20240315191353029.png" alt="image-20240315191353029" style="zoom: 67%;" /></p><p>应对这种情况，可以考虑采取<strong>延迟双删</strong>的策略，即先删缓存，再更新数据库，然后延迟一段时间再删除缓存</p><blockquote><p>关于为什么要延时，如图：</p><p><img src="/images/image-20240315191511454.png" alt="image-20240315191511454" style="zoom:80%;" /></p><p>延迟一段时间是为了确保 <strong>修改数据库 -&gt; 清空缓存前，其他事务的写入缓存操作已经执行完。</strong><br>同时，如果MySQL是集群模式，需要时间完成主从同步更新，防止删除缓存后从从库读取到旧数据写入缓存</p><p>但是，<strong>延迟的时间不好确定</strong>，延时的过程也可能读取到脏数据，不能保证强一致性</p></blockquote><h3 id="先更新数据库"><a href="#先更新数据库" class="headerlink" title="先更新数据库"></a>先更新数据库</h3><p>这种情况虽然也会出现数据不一致的情况，但在实际中出现的概率比较低，</p><p>因为<strong>写入缓存比更新数据库要快得多</strong>，只有很小的概率会在<code>读取到旧数据</code>和<code>写入旧数据缓存</code>中间插入<code>更新数据库</code>的操作，可以再设置一个超时时间作为兜底（或在这里也进行<code>延迟双删</code>）</p><p>在实际开发中如果对数据没有强一致性的要求，可以接受</p><p><img src="/images/image-20240315191609914.png" alt="image-20240315191609914" style="zoom:67%;" /></p><p>这种策略又被称为Cache-Aside Pattern（旁路缓存模式）：</p><ul><li><strong>更新流程</strong>：先写数据库，写成功后再删除缓存。</li><li><strong>读流程</strong>：先读缓存，缓存未命中则读数据库，然后将数据库中的数据写入缓存。</li><li><strong>优点</strong>：简单易理解，容易实现。</li><li><strong>缺点</strong>：可能会出现短暂的数据不一致情况。</li></ul><blockquote><p>但是，这种方案需要考虑缓存删除失败的情况，</p><ul><li>可以通过消息队列的重试机制异步删除缓存</li><li>也可以通过阿里巴巴的canal数据库同步工具监听MySQL的binlog日志，异步更新缓存</li></ul></blockquote><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><blockquote><p>如何保证数据的强一致性呢？</p></blockquote><p>上面两种方案都可能存在短暂的数据不一致，即读取到脏数据情况，如果业务要求数据强一致性，则需要考虑加分布式锁，保证数据库和缓存更新的操作只有一个线程执行，避免并发问题。</p><p>可以考虑使用<strong>Redisson</strong>提供的<code>读写锁</code>：</p><ul><li>在更新操作时添加写锁，保证读写，写写互斥，避免并发情况下造成数据不一致的情况</li><li>在读取数据是添加写锁，读锁和读锁之间不会互斥，读写互斥，提高读取的效率</li></ul><p>当然，加锁的性能肯定比不加锁的低，在时间开发中需要根据业务需求权衡选择方案。</p><blockquote><p>为什么是删除缓存，而不是更新缓存呢？</p></blockquote><p>删除一个数据，相比更新一个数据更加轻量级，出问题的概率更小。在实际业务中，缓存的数据可能不是直接来自数据库表，也许来自多张底层数据表的聚合。</p><p>比如商品详情信息，在底层可能会关联商品表、价格表、库存表等，如果更新了一个价格字段，那么就要更新整个数据库，还要关联的去查询和汇总各个周边业务系统的数据，这个操作会非常耗时。 从另外一个角度，不是所有的缓存数据都是频繁访问的，更新后的缓存可能会长时间不被访问，所以说，从计算资源和整体性能的考虑，更新的时候删除缓存，等到下次查询命中再填充缓存，是一个更好的方案。</p><p>系统设计中有一个思想叫 Lazy Loading，适用于那些加载代价大的操作，删除缓存而不是更新缓存，就是懒加载思想的一个应用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在分布式系统中，双写一致性问题是指当系统同时对缓存（如 Redis）和数据库（如 MySQL）进行写操作时，如何保证这两个数据存储之间数据的一致性。这是一个非常常见但又难以解决的问题，因为缓存系统和数据库系统通常是独立运行的，它们之间无法自动同步数据变更，从而可能导致数据不</summary>
      
    
    
    
    <category term="技术" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Redis" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/Redis/"/>
    
    
    <category term="八股" scheme="https://kkwans.cn/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="Redis" scheme="https://kkwans.cn/tags/Redis/"/>
    
    <category term="缓存" scheme="https://kkwans.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="数据库" scheme="https://kkwans.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>传输控制协议——TCP</title>
    <link href="https://kkwans.cn/post/36b7363b.html"/>
    <id>https://kkwans.cn/post/36b7363b.html</id>
    <published>2024-02-25T02:20:16.000Z</published>
    <updated>2024-03-24T08:51:05.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>TCP</strong>（Transmission Control Protocol，传输控制协议）是一种在计算机网络中常用的通信协议，位于网络协议栈的传输层。它提供了可靠的、面向连接的数据传输服务，被广泛应用于互联网及局域网中各种网络通信场景。</p><p>TCP的主要特点包括：</p><ol><li><strong>可靠性</strong>：TCP通过序列号、确认和重传机制来确保数据的可靠传输。每个数据包都会标记一个序列号，接收方收到数据后会发送确认，发送方在一定时间内未收到确认就会重传数据，以保证数据能够正确到达。</li><li><strong>面向连接</strong>：在进行数据传输之前，TCP会先建立连接，包括三次握手过程，确保通信双方都能正常通信。数据传输完成后，还需要进行连接的释放，包括四次挥手过程。</li><li><strong>流量控制</strong>：TCP使用滑动窗口机制进行流量控制，确保发送方发送的数据不会超过接收方的处理能力，避免数据丢失或网络拥塞。</li><li><strong>拥塞控制</strong>：TCP使用拥塞窗口和拥塞避免算法来控制数据在网络中的传输速率，以防止网络拥塞和丢包情况的发生，从而保证网络的稳定性和性能。</li><li><strong>全双工通信</strong>：TCP连接是全双工的，允许双方同时发送和接收数据，实现了双向通信。</li><li><strong>面向字节流</strong>：TCP将数据视为连续的字节流进行传输，没有消息边界的概念，接收方需要根据应用协议来解析数据。</li></ol><p>TCP在互联网中被广泛应用于各种网络应用中，如Web浏览、文件传输、电子邮件等，其可靠性和稳定性使其成为网络通信中不可或缺的一部分。</p><h1 id="知识要点"><a href="#知识要点" class="headerlink" title="知识要点"></a>知识要点</h1><h2 id="TCP报文的首部格式"><a href="#TCP报文的首部格式" class="headerlink" title="TCP报文的首部格式"></a>TCP报文的首部格式</h2><p><img src="/images/1.png" alt="img"></p><p>TCP报文的首部包含以下各个字段：</p><ol><li><strong>源端口</strong>：占16位，表示发送方的端口号。</li><li><strong>目的端口</strong>：占16位，表示接收方的端口号。</li><li><strong>序列号</strong>：占32位，用于对发送的数据进行排序和重组。</li><li><strong>确认号</strong>：占32位，表示期望接收的下一个数据字节的序号。</li><li><strong>数据偏移</strong>：占4位，表示TCP头部的长度，以32位字为单位。</li><li><strong>保留</strong>：占6位，留待将来使用，目前必须为0。</li><li><strong>标志位</strong>：占6位，包括URG、ACK、PSH、RST、SYN和FIN，用于控制TCP连接的建立、终止和数据传输过程。</li><li><strong>窗口大小</strong>：占16位，表示发送方愿意接收的窗口大小，用于流量控制。</li><li><strong>校验和</strong>：占16位，用于检测TCP首部和数据在传输过程中是否出现错误。</li><li><strong>紧急指针</strong>：占16位，用于指示紧急数据的末尾位置。</li><li><strong>选项</strong>：可选字段，用于在TCP头部中包含一些额外的控制信息，如选择性确认、最大报文大小等。</li><li><strong>数据</strong>：占可变长度，用于存储应用层的数据。</li></ol><p>这些字段共同组成了TCP报文的首部，用于在TCP通信中标识和管理数据传输。</p><p>TCP报文的标志位字段包含6个位，用于控制TCP连接的建立、终止和数据传输过程。下面是对每个标志位的介绍：</p><ol><li><strong>URG（Urgent）</strong>：紧急指针（Urgent Pointer）有效。当此标志位被设置时，表示紧急数据存在于TCP数据流中，并且紧急指针字段指示了紧急数据的末尾位置。紧急数据用于在正常数据传输之外发送一些重要的控制信息。</li><li><strong>ACK（Acknowledgment）</strong>：确认号（Acknowledgment Number）有效。<strong>当此标志位被设置为1时，表示确认号字段中包含的确认序列号有效</strong>，即接收方已经成功接收到了发送方期望接收的数据。</li><li><strong>PSH（Push）</strong>：推送数据（Push）。当此标志位被设置时，表示发送方希望尽快将数据推送给接收方，而不需要等到发送缓冲区满或者等待ACK确认。</li><li><strong>RST（Reset）</strong>：连接复位（Reset）。当此标志位被设置时，表示发生严重错误，要求对方重新建立连接。通常用于异常情况下的连接复位。</li><li><strong>SYN（Synchronize）</strong>：同步序列号（Synchronize Sequence Numbers）。用于建立连接时的同步序列号的交换。在三次握手的过程中，<strong>SYN用于请求建立连接</strong>，并且包含了发送方的初始序列号。</li><li><strong>FIN（Finish）</strong>：结束连接（Finish）。当此标志位被设置时，表示发送方已经没有数据要发送了，并请求关闭连接。通常用于正常的连接终止过程中。</li></ol><h2 id="TCP连接的建立与释放"><a href="#TCP连接的建立与释放" class="headerlink" title="TCP连接的建立与释放"></a>TCP连接的建立与释放</h2><h3 id="TCP连接的建立"><a href="#TCP连接的建立" class="headerlink" title="TCP连接的建立"></a>TCP连接的建立</h3><h4 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h4><p><img src="/images/2.png" alt="img"></p><ol><li><strong>第一次握手（SYN）</strong>：<ul><li>客户端发送一个带有SYN标志位的TCP报文段，指示客户端要求建立连接。</li><li>这个报文段中包含了客户端的初始序列号（Sequence Number），用来标识客户端发送的数据。</li></ul></li><li><strong>第二次握手（SYN + ACK）</strong>：<ul><li>服务器接收到客户端的SYN报文段后，会发送一个带有SYN和ACK标志位的TCP报文段作为响应。</li><li>这个报文段中确认了客户端的序列号，并且也包含了服务器的初始序列号。</li></ul></li><li><strong>第三次握手（ACK）</strong>：<ul><li>客户端收到服务器的SYN + ACK报文段后，会向服务器发送一个带有ACK标志位的TCP报文段。</li><li>这个报文段中确认了服务器的序列号，表示客户端已经接受到了服务器的确认，并且连接已经建立完成。此时也可以发送应用层的数据</li></ul></li></ol><h4 id="可不可以两次握手？"><a href="#可不可以两次握手？" class="headerlink" title="可不可以两次握手？"></a>可不可以两次握手？</h4><p><img src="/images/4.png" alt="img"></p><p>如果一开始发送的TCP连接请求因为过去了很久很久才到达了TCP服务器，因为是两次握手，TCP服务器会直接进入连接建立状态。同时这个时候TCP服务器会不断发送响应请求，但此时TCP客户处于关闭状态，这样会造成很大的资源浪费。</p><h3 id="TCP连接的释放"><a href="#TCP连接的释放" class="headerlink" title="TCP连接的释放"></a>TCP连接的释放</h3><h4 id="流程概述-1"><a href="#流程概述-1" class="headerlink" title="流程概述"></a>流程概述</h4><p><img src="/images/5.png" alt="img"><br><strong>TCP四次挥手的过程：</strong></p><ol><li><strong>第一次挥手（FIN）</strong>：<ul><li>客户端或服务器其中一方决定关闭连接（<code>主动关闭方</code>），发送一个带有FIN标志位的TCP报文给对方，表示自己不再发送数据，但仍愿意接收数据，进入<code>终止等待状态1</code>。</li></ul></li><li><strong>第二次挥手（ACK）</strong>：<ul><li>接收到 主动关闭方 的FIN后，<code>被动关闭方</code> 会发送一个带有ACK标志位的TCP报文，确认收到了对方的FIN，并且进入<code>关闭等待状态</code>，此时，该方可以继续发送数据。</li><li>而 <code>主动关闭方</code> 在接收到第二次挥手后，进入<code>终止等待状态2</code>准备接收数据。</li></ul></li><li><strong>第三次挥手（FIN）</strong>：<ul><li>在 <code>被动关闭方</code> 发送完数据后，也决定关闭连接，于是发送一个带有FIN标志位的TCP报文给对方，表示自己准备好关闭连接，进入<code>最后确认状态</code>。</li></ul></li><li><strong>第四次挥手（ACK）</strong>：<ul><li><code>主动关闭方</code> 在收到了对方的FIN后，发送一个带有ACK标志位的TCP报文给对方，确认可以关闭连接，之后进入<code>时间等待状态</code>，2SML之后自动关闭连接</li><li><code>被动关闭方</code> 接收到第四次挥手后正式<code>关闭</code>连接。</li></ul></li></ol><h4 id="可不可以三次挥手？"><a href="#可不可以三次挥手？" class="headerlink" title="可不可以三次挥手？"></a>可不可以三次挥手？</h4><p>如果缺少第四次ACK挥手，只有三次挥手，那么服务器（被动关闭方）将会在发送第三次挥手信息之后关闭，TCP客户（主动关闭方）将会在收到第三次挥手信息之后关闭。但是如果第三次挥手信息中途丢失了，但是服务器此时又直接关闭了，那么客户将一直拿不到最后一次的数据，也没有办法发送ack报文要求对方重传。客户机将一直挂起。</p><p>但在实际应用中，如果被动关闭方在接收到第一次挥手信息后没有数据要发送，可以将第二次和第三次挥手合并，即最终只用三次挥手就可以完成TCP连接的释放。</p><h4 id="为什么最后一次挥手之后还要等待2MSL"><a href="#为什么最后一次挥手之后还要等待2MSL" class="headerlink" title="为什么最后一次挥手之后还要等待2MSL"></a>为什么最后一次挥手之后还要等待2MSL</h4><p><img src="/images/6.png" alt="img"></p><p>如图所示，当第四次挥手的报文丢失之后，TCP服务器会超时重传重新发送第三次挥手的报文信息，但是如果此时TCP进入关闭状态，那么TCP服务器将迟迟收不到响应，将会一直进行超时重传，所以需要等待。<br>为什么等待的刚好是2MSL? 2MSL 的时间刚好够客户自己的报文发送出去并且丢失，加上TCP服务器超时重传的时间。</p><h2 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h2><p><img src="/images/7.png" alt="img"></p><p>初始在建立连接的时候，双方就会确定发送窗口的大小，假设初始确定的滑动窗口大小为400.</p><p>若A发送速率过快，导致B的处理不过来，则B会缩小接收窗口，通过对发送端A的发送窗口进行流量控制</p><p><img src="/images/8.png" alt="img"></p><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><p><img src="/images/9.png" alt="img"></p><ol><li><strong>慢启动（Slow Start）</strong>：<ul><li>在TCP连接建立或拥塞恢复时，慢启动算法将初始的拥塞窗口设置为1个报文段大小，并且每当收到一个确认就将窗口大小加倍，从而实现指数级的增长。</li></ul></li><li><strong>拥塞避免（Congestion Avoidance）</strong>：<ul><li>当拥塞窗口大小达到慢启动阈值（ssthresh）时，TCP会进入拥塞避免状态。在拥塞避免状态下，拥塞窗口以线性增长的方式增加，每当一个往返时间（RTT）过去时，拥塞窗口增加一个报文段大小。</li></ul></li><li><strong>快重传（Fast Retransmit）</strong>：<ul><li>如果发送方接收到对同一个数据包的三个重复的ACK确认，它会认为这个数据包已经丢失，并立即重传该数据包，而不必等待超时。</li></ul></li><li><strong>快恢复（Fast Recovery）</strong>：<ul><li>当发送方收到三个重复的ACK时，它会将拥塞窗口减半（而不是将其设置为1，这与慢启动不同），并将慢启动阈值设置为当前拥塞窗口的一半。接着，它进入快速恢复状态，在此状态下，拥塞窗口每收到一个 ACK 就增加一个报文段大小，而不是每次加倍，这相对于慢启动算法来说是一种更加保守的方法。</li></ul></li></ol><p>拥塞检测并没有单独的算法，它是快重传和快恢复算法的一部分，在出现丢失的数据包时，通过快速重传和快速恢复算法来尽快检测并纠正拥塞。</p><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="TCP连接建立后客户机突然宕机了怎么办？"><a href="#TCP连接建立后客户机突然宕机了怎么办？" class="headerlink" title="TCP连接建立后客户机突然宕机了怎么办？"></a>TCP连接建立后客户机突然宕机了怎么办？</h2><p>TCP Keep-Alive是一种TCP协议的扩展机制，用于检测TCP连接的存活状态。它通过在连接空闲时定期向对方发送探测报文来检测连接的存活性，以防止连接因为长时间的空闲而被网络设备或中间节点关闭。<br>TCP Keep-Alive的工作原理如下：</p><ol><li><strong>定时发送探测报文</strong>：一旦TCP连接空闲超过一定的时间阈值，TCP Keep-Alive机制就会启动。发送方会定期向对方发送特殊的Keep-Alive探测报文，以确认对方是否仍然处于活动状态。</li><li><strong>等待对方响应</strong>：发送方发送Keep-Alive探测报文后，会等待一定的时间来等待对方的响应。如果对方没有响应，则表示连接可能已经失效。</li><li><strong>关闭连接</strong>：如果在一定的等待时间内没有收到对方的响应，发送方就会认为连接已经失效，并关闭连接释放资源。这样可以及时清除无效的连接，避免资源的浪费。</li></ol><p>TCP Keep-Alive的参数可以由操作系统或应用程序设置，包括Keep-Alive探测报文的发送间隔、空闲连接超时时间和最大尝试次数等。这些参数可以根据具体的应用场景和网络环境进行调整，以平衡连接的可靠性和性能开销。</p><p>保活计时器是TCP Keep-Alive机制中的一个关键组成部分，用于控制发送Keep-Alive探测报文的定时发送和超时等待。保活计时器通常由操作系统维护，它会在TCP连接空闲一定时间后启动，并定期发送Keep-Alive探测报文。如果在一定的时间内没有收到对方的响应，保活计时器会触发连接的关闭。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;（Transmission Control Protocol，传输控制协议）是一种在计算机网络中常用</summary>
      
    
    
    
    <category term="技术" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="计算机网络" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="八股" scheme="https://kkwans.cn/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="计网" scheme="https://kkwans.cn/tags/%E8%AE%A1%E7%BD%91/"/>
    
    <category term="传输层" scheme="https://kkwans.cn/tags/%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>AOP的的实现方式——动态代理</title>
    <link href="https://kkwans.cn/post/ab428168.html"/>
    <id>https://kkwans.cn/post/ab428168.html</id>
    <published>2024-02-21T07:32:16.000Z</published>
    <updated>2024-03-23T10:13:36.713Z</updated>
    
    <content type="html"><![CDATA[<p>AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在提高代码的模块化程度。AOP通过将横切关注点（如日志、事务管理等）从业务逻辑代码中分离出来，来提高代码的可维护性和复用性。在Java中，AOP通常是通过动态代理来实现的。动态代理主要有两种实现方式：基于接口的JDK动态代理和基于类的CGLIB动态代理。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>JDK动态代理是通过实现接口的方式来创建代理对象的。其原理是在运行时动态地在内存中构建代理对象，并实现指定的接口。使用<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口来创建代理对象和自定义方法调用的处理逻辑。</p><ul><li><p><strong>实现步骤</strong>：</p><ol><li>创建一个实现<code>InvocationHandler</code>接口的处理器类，重写<code>invoke</code>方法，定义代理对象调用方法时的行为。</li><li>使用<code>Proxy.newProxyInstance</code>方法，传入类加载器、接口数组和上一步创建的调用处理器，动态创建代理对象。</li></ol></li><li><p><strong>示例代码</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object target; <span class="comment">// 目标对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyInvocationHandler</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args); <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="comment">// 在目标方法执行后可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">MyInterface</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyInterface) Proxy.newProxyInstance(</span><br><span class="line">    MyInterface.class.getClassLoader(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123;MyInterface.class&#125;,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>(<span class="keyword">new</span> <span class="title class_">MyInterfaceImpl</span>())</span><br><span class="line">);</span><br><span class="line">proxy.someMethod();</span><br></pre></td></tr></table></figure><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB（Code Generation Library）是一个第三方代码生成库，它允许在运行时动态生成新的类。CGLIB动态代理不需要基于接口，它是通过继承目标类并重写其方法来实现代理的。</p><ul><li><p><strong>实现步骤</strong>：</p><ol><li>创建一个继承<code>MethodInterceptor</code>接口的拦截器类，并重写<code>intercept</code>方法，定义方法调用的拦截逻辑。</li><li>使用<code>Enhancer</code>类创建代理对象，设置父类为目标类，并设置回调拦截器。</li></ol></li><li><p><strong>示例代码</strong>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMethodInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 在目标方法执行前可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Before method call&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args); <span class="comment">// 调用目标方法</span></span><br><span class="line">        <span class="comment">// 在目标方法执行后可以添加自定义逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;After method call&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">enhancer.setSuperclass(MyClass.class); <span class="comment">// 设置父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MyMethodInterceptor</span>()); <span class="comment">// 设置方法拦截器</span></span><br><span class="line"><span class="type">MyClass</span> <span class="variable">proxy</span> <span class="operator">=</span> (MyClass) enhancer.create();</span><br><span class="line">proxy.someMethod();</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>AOP利用动态代理技术在运行时对方法调用进行拦截和增强，实现了横切关注点与业务逻辑的分离。JDK动态代理和CGLIB代理是实现动态代理的两种主要方式，前者依赖接口，后者可以直接代理类。在Spring框架中，根据目标对象是否实现了接口，自动选择使用JDK动态代理还是CGLIB代理来实现AOP。</p><hr><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="JDK动态代理-1"><a href="#JDK动态代理-1" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><p>JDK动态代理是Java中一种基于接口的动态代理技术。它允许在运行时动态地创建一个代理对象，这个代理对象可以实现目标对象所实现的接口。JDK动态代理通过反射机制实现，它要求目标对象必须实现一个或多个接口。在代理对象中，开发者可以实现横切逻辑，从而在方法执行前后添加额外的功能。</p><p>以下是使用JDK动态代理的一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  目标类，实现了接口</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">interface</span>  <span class="title class_">MyInterface</span>  &#123;</span><br><span class="line">     <span class="keyword">void</span>  <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">MyClass</span>  <span class="keyword">implements</span>  <span class="title class_">MyInterface</span>  &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">doSomething</span><span class="params">()</span>  &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;执行目标方法&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  代理类，实现了InvocationHandler接口</span></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">MyInvocationHandler</span>  <span class="keyword">implements</span>  <span class="title class_">InvocationHandler</span>  &#123;</span><br><span class="line">     <span class="keyword">private</span>  <span class="keyword">final</span>  Object  target;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span>  <span class="title function_">MyInvocationHandler</span><span class="params">(Object  target)</span>  &#123;</span><br><span class="line">          <span class="built_in">this</span>.target  =  target;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span>  Object  <span class="title function_">invoke</span><span class="params">(Object  proxy,  Method  method,  Object[]  args)</span>  <span class="keyword">throws</span>  Throwable  &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;执行横切逻辑...&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span>  method.invoke(target,  args);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span>  <span class="title class_">Main</span>  &#123;</span><br><span class="line">     <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title function_">main</span><span class="params">(String[]  args)</span>  &#123;</span><br><span class="line">         <span class="comment">//  创建目标对象</span></span><br><span class="line">         <span class="type">MyClass</span>  <span class="variable">myClass</span>  <span class="operator">=</span>  <span class="keyword">new</span>  <span class="title class_">MyClass</span>();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//  创建代理对象</span></span><br><span class="line">         <span class="type">MyInterface</span>  <span class="variable">myInterface</span>  <span class="operator">=</span>  (MyInterface)  Proxy.newProxyInstance(</span><br><span class="line">                 myClass.getClass().getClassLoader(),  <span class="comment">//  类加载器</span></span><br><span class="line">                 myClass.getClass().getInterfaces(),  <span class="comment">//  目标对象实现的接口</span></span><br><span class="line">                 <span class="keyword">new</span>  <span class="title class_">MyInvocationHandler</span>(myClass)  <span class="comment">//  方法调用的处理器</span></span><br><span class="line">         );</span><br><span class="line"></span><br><span class="line">         <span class="comment">//  通过代理对象调用目标方法</span></span><br><span class="line">         myInterface.doSomething();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>MyClass</code>实现了<code>MyInterface</code>接口，<code>MyInvocationHandler</code>实现了<code>InvocationHandler</code>接口。通过<code>Proxy.newProxyInstance()</code>方法创建代理对象，将<code>MyClass</code>作为目标对象传递给这个方法。在<code>MyInvocationHandler</code>的<code>invoke()</code>方法中，可以添加横切逻辑，例如日志记录、事务管理等。最后，通过代理对象<code>myInterface</code>调用目标方法<code>doSomhing()</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AOP（Aspect-Oriented Programming，面向切面编程）是一种编程范式，旨在提高代码的模块化程度。AOP通过将横切关注点（如日志、事务管理等）从业务逻辑代码中分离出来，来提高代码的可维护性和复用性。在Java中，AOP通常是通过动态代理来实现的。动态代</summary>
      
    
    
    
    <category term="技术" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="Spring" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/Spring/"/>
    
    
    <category term="八股" scheme="https://kkwans.cn/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="AOP" scheme="https://kkwans.cn/tags/AOP/"/>
    
    <category term="动态代理" scheme="https://kkwans.cn/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    <category term="设计模式" scheme="https://kkwans.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JUC的核心——AQS</title>
    <link href="https://kkwans.cn/post/f3171170.html"/>
    <id>https://kkwans.cn/post/f3171170.html</id>
    <published>2024-02-14T01:25:38.000Z</published>
    <updated>2024-03-23T10:12:36.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS(AbstractQueuedSynchronizer)是一个多线程同步器，它是JUC并发包中多个组件的底层实现，比如ReentrantLock、CountDownLatch、Semaphore等都是通过ASQ实现的。</p><p>AQS提供了两种锁的机制，分别是排它锁（独占模式）和共享锁（共享模式）</p><ul><li><strong>排它锁</strong>存在多个线程竞争锁资源，同一时刻只允许一个线程访问共享资源,<code>ReentrantLock</code>就是通过AQS的独占模式实现排他锁</li><li><strong>共享锁</strong>类似于读锁,在同一时刻运行多个线程获取共享资源，<code>CountDownLatch</code>、<code>Semaphore</code>都用到了共享锁的实现</li></ul><p>ASQ 内部维护了一个<code>int</code>变量<code>state</code>(volatile修饰）用来记录锁竞争时的状态，<br>在独占模式下，当有线程想要获取锁资源，需要先判断state==0，如果等于0表示无锁状态，将其更新为1表示该线程独占了锁资源，<br>在多线程情况下这种操作可能造成线程安全问题，因此需要通过<code>CAS</code>更新<code>state</code>状态保证<code>线程安全</code></p><p>未竞争到锁的线程会调用<code>Unsafe</code>类中的<code>park</code>方法进行阻塞，然后将阻塞的线程 按照<code>先进先出</code>原则放入AQS内维护的<strong>双向链表</strong><code>等待队列</code>（又称阻塞队列、同步队列，借鉴<code>CHL</code>锁实现。类似于 Monitor 的 EntryList，插入前将该线程包装成一个 Node 节点，然后将其插入队列的尾部。）<br>当持有锁的线程释放锁时，AQS会将等待队列中的第一个线程唤醒，并让其重新尝试获取锁</p><p>AQS可以实现公平锁和非公平锁，其区别体现在：<br>有新的线程竞争锁时，公平锁需要先判断等待队列中是否有阻塞的队列，若有，则需要排队等待<br>而非公平锁不管在其之前是否有等待阻塞的线程，都会直接参与锁的竞争而不用先排队</p><p>以上是我对AQS的一点理解</p><hr><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h3><p>AQS中还有一个条件变量<code>ConditionObject</code> 类似于 Monitor 的 <code>WaitSet</code></p><p>ConditionObject是AQS的一个内部类，用于实现条件变量。条件变量是并发编程中一种用于线程间通信的机制，它允许一个或多个线程在特定条件成立之前等待，同时释放相关的锁。这在某种程度上类似于对象监视器模式中的wait()和notify()方法，但提供了更灵活和更强大的控制。</p><p>条件队列与同步队列不同，它是基于Condition接口实现的，用于管理那些因为某些条件未满足而等待的线程。当条件满足时，这些线程可以被唤醒。每个Condition对象都有自己的一个条件队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConditionObject</span> <span class="keyword">implements</span> <span class="title class_">Condition</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">// 条件队列的首尾节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当线程调用了Condition的await()方法后，它会释放当前持有的锁，并且该线程会被加入到条件队列中等待，直到被另一个线程的signal()或signalAll()方法唤醒，或被中断。</li><li>signal()：唤醒等待队列中的头节点对应的线程。<br>  signalAll()：唤醒所有等待的线程。</li></ul><blockquote><p>条件队列和同步队列，主要有以下区别：</p><ul><li><strong>目的不同</strong>：同步队列主要用于管理锁的获取和释放，而条件队列用于等待特定条件的满足。</li><li><strong>使用方式不同</strong>：同步队列是AQS自动管理的，开发者通常不需要直接与之交互；而条件队列是通过Condition接口暴露给开发者的，需要显式地调用等待（await）和通知（signal/signalAll）方法。</li><li><strong>队列类型不同</strong>：虽然它们都是队列结构，但同步队列是所有基于AQS同步器共享的，每个同步器实例只有一个同步队列；条件队列是每个Condition实例特有的，一个同步器可以有多个Condition对象，因此也就有多个条件队列。</li></ul></blockquote><h3 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h3><p>CLH（Craig, Landin, and Hagersten）锁是一种基于链表的可扩展、高性能、公平的自旋锁，广泛应用于实现锁机制。CLH锁的主要思想是将锁的拥有者和等待者分离，锁状态不再保存在锁对象本身，而是保存在线程（或CPU）的本地变量中。这种设计减少了锁的竞争，使得锁的获取更加高效，同时也保证了公平性。</p><h4 id="CLH锁的基本结构"><a href="#CLH锁的基本结构" class="headerlink" title="CLH锁的基本结构"></a>CLH锁的基本结构</h4><p>CLH锁使用一个隐式的链表来维护锁的等待队列。每个节点（通常代表一个线程）包含一个标志位，表示该线程是否在等待锁。节点被组织成一个FIFO（先进先出）队列，确保了锁的公平性。</p><h4 id="CLH锁的工作原理"><a href="#CLH锁的工作原理" class="headerlink" title="CLH锁的工作原理"></a>CLH锁的工作原理</h4><ol><li><p><strong>锁获取</strong>：当一个线程尝试获取锁时，它会创建一个新的队列节点，并将其自己的节点设置为“锁定”状态。然后，它将自己的节点插入到队列的末尾，并检查前一个节点的状态：</p><ul><li>如果前一个节点的状态是“未锁定”，则当前线程可以获取锁并进入临界区。</li><li>如果前一个节点的状态是“锁定”，则当前线程需要自旋等待，直到前一个节点释放锁（即前一个节点的状态变为“未锁定”）。</li></ul></li><li><p><strong>锁释放</strong>：当一个线程完成其临界区的执行并准备释放锁时，它只需要将其节点的状态设置为“未锁定”。这会让后续的节点（如果有的话）注意到锁已经被释放，从而尝试获取锁。</p></li></ol><h4 id="CLH锁的优点"><a href="#CLH锁的优点" class="headerlink" title="CLH锁的优点"></a>CLH锁的优点</h4><ul><li><strong>高效的锁获取和释放</strong>：由于锁的状态保存在本地变量中，线程获取和释放锁时减少了对共享变量的访问，降低了系统的总体开销。</li><li><strong>公平性</strong>：CLH锁通过FIFO队列确保了每个线程都能按照请求锁的顺序获得锁，避免了“饥饿”现象。</li><li><strong>可扩展性</strong>：CLH锁的设计减少了锁的争用，使得它在多处理器系统中表现出良好的扩展性。</li></ul><h4 id="CLH锁的应用"><a href="#CLH锁的应用" class="headerlink" title="CLH锁的应用"></a>CLH锁的应用</h4><p>CLH锁因其高效和公平的特性，被广泛应用于实现各种并发数据结构和同步机制，特别是在多处理器系统中。Java的<code>java.util.concurrent.locks</code>包中的<code>ReentrantLock</code>在其公平模式下内部使用了类似CLH锁的变种来实现锁的管理。</p><h4 id="CLH队列和AQS的关系"><a href="#CLH队列和AQS的关系" class="headerlink" title="CLH队列和AQS的关系"></a>CLH队列和AQS的关系</h4><ol><li><strong>设计思想上的继承</strong>：AQS在设计上借鉴了CLH队列锁的思想，特别是在管理等待线程方面。AQS中的等待队列虽然是显式的（每个节点都是显式创建的），但其公平性和FIFO的特性与CLH队列锁相似。</li><li><strong>自旋的应用</strong>：虽然AQS不直接使用CLH锁的自旋机制，但它提供了基础设施，允许构建在其上的同步器根据需要实现自旋等待，这在某种程度上反映了CLH锁设计的影响。</li><li><strong>节点的状态管理</strong>：AQS中的每个节点代表一个等待获取锁的线程，这与CLH队列中每个节点代表一个等待状态的线程的概念相似。AQS通过状态变量和队列节点的管理实现了复杂的同步语义，而CLH锁则更专注于实现高效的自旋锁。</li><li><strong>锁的公平性</strong>：AQS支持创建公平锁和非公平锁，其中公平锁的实现保证了按照请求锁的顺序来获取锁，这与CLH队列锁的公平性原则相吻合。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h2&gt;&lt;p&gt;AQS(AbstractQueuedSynchronizer)是一个多线程同步器，它是JUC并发包中多个组件的底层实现，比如Reen</summary>
      
    
    
    
    <category term="技术" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="JUC" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/JUC/"/>
    
    
    <category term="八股" scheme="https://kkwans.cn/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="多线程" scheme="https://kkwans.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="锁" scheme="https://kkwans.cn/tags/%E9%94%81/"/>
    
    <category term="AQS" scheme="https://kkwans.cn/tags/AQS/"/>
    
    <category term="CLH" scheme="https://kkwans.cn/tags/CLH/"/>
    
  </entry>
  
  <entry>
    <title>如何保证线程执行顺序？</title>
    <link href="https://kkwans.cn/post/9e10e520.html"/>
    <id>https://kkwans.cn/post/9e10e520.html</id>
    <published>2024-02-11T11:03:53.000Z</published>
    <updated>2024-03-23T10:18:42.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？"><a href="#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？"></a>新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？</h2><h3 id="1-使用join-方法"><a href="#1-使用join-方法" class="headerlink" title="1. 使用join()方法"></a>1. 使用<code>join()</code>方法</h3><p>这是最简单直接的方法，通过调用前一个线程的<code>join()</code>方法，可以让当前线程等待直到前一个线程结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; System.out.println(<span class="string">&quot;T1运行&quot;</span>));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t1.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t2.join();</span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-使用CountDownLatch"><a href="#2-使用CountDownLatch" class="headerlink" title="2. 使用CountDownLatch"></a>2. 使用<code>CountDownLatch</code></h3><p><code>CountDownLatch</code>是一种同步辅助工具，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">latch2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1运行&quot;</span>);</span><br><span class="line">            latch1.countDown(); <span class="comment">// 减少计数</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latch1.await(); <span class="comment">// 等待latch1归零</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">                latch2.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                latch2.await(); <span class="comment">// 等待latch2归零</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-使用CyclicBarrier"><a href="#3-使用CyclicBarrier" class="headerlink" title="3. 使用CyclicBarrier"></a>3. 使用<code>CyclicBarrier</code></h3><p><code>CyclicBarrier</code>是一种同步辅助工具，它允许一组线程相互等待，达到一个公共屏障点(common barrier point)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1运行&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// doing someting...</span></span><br><span class="line">                barrier1.await(); <span class="comment">// 等待T2准备就绪</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier1.await(); <span class="comment">// 确保T1已运行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">                barrier2.await(); <span class="comment">// 等待T3准备就绪</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier2.await(); <span class="comment">// 确保T2已运行</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用Semaphore"><a href="#4-使用Semaphore" class="headerlink" title="4. 使用Semaphore"></a>4. 使用<code>Semaphore</code></h3><p><code>Semaphore</code>是一种基于计数的信号量。它可以设置信号量的初始值，用于多线程间的协调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrder</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">sem1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">Semaphore</span> <span class="variable">sem2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;T1运行&quot;</span>);</span><br><span class="line">            sem1.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sem1.acquire(); <span class="comment">// 请求一个许可</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T2运行&quot;</span>);</span><br><span class="line">                sem2.release();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sem2.acquire(); <span class="comment">// 请求一个许可</span></span><br><span class="line">                System.out.println(<span class="string">&quot;T3运行&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="文字描述"><a href="#文字描述" class="headerlink" title="文字描述"></a>文字描述</h2><p>首先，我们需要了解线程是并发执行的，所以默认情况下它们的执行顺序是不确定的。但是，有时我们需要它们按照特定的顺序来执行。为了实现这一点，我们可以使用几种同步机制：</p><ol><li><p><strong>使用<code>join()</code>方法</strong>：这是最直接的方法。当我们想要确保当前线程在另一个线程<code>T</code>完成之后再执行时，我们可以在当前线程中调用<code>T.join()</code>。这会让当前线程等待，直到线程<code>T</code>执行完毕。这种方法简单易用，但是它不够灵活，因为它要求线程严格地一个接一个地执行。</p></li><li><p><strong>使用<code>CountDownLatch</code></strong>：这是一个高级的同步辅助类。它允许一个或多个线程等待一系列其他线程完成执行。我们可以给<code>CountDownLatch</code>一个初始的计数值，每当一个线程完成了它的任务，它就调用<code>countDown()</code>方法。其他线程可以通过调用<code>await()</code>方法来等待计数器达到零。这种方法比<code>join()</code>更灵活，因为它允许多个线程等待其他线程的操作。</p></li><li><p><strong>使用<code>CyclicBarrier</code></strong>：这个同步辅助类允许一组线程互相等待，直到所有线程都达到了一个公共的屏障点。与<code>CountDownLatch</code>不同的是，<code>CyclicBarrier</code>是可以重用的。这对于需要所有线程在继续执行前达到某个公共点的情况很有用。</p></li><li><p><strong>使用<code>Semaphore</code></strong>：这是一个基于计数的同步机制。我们可以初始化一个<code>Semaphore</code>并给它一个许可的数量。线程可以通过<code>acquire()</code>方法获取许可，如果没有可用的许可，线程将等待。一旦线程执行完毕，它可以通过<code>release()</code>方法释放许可。通过控制许可的分配，我们可以控制线程的执行顺序。</p></li></ol><p>在实际的应用中，选择哪种同步机制取决于我们的具体需求。例如，如果我们只是想让线程顺序执行并且不会再次使用这些线程，<code>join()</code>可能是最简单的方法。但如果我们需要更复杂的同步，比如允许一组线程等待另一组线程完成，或者需要一个可以重用的同步点，那么<code>CountDownLatch</code>和<code>CyclicBarrier</code>可能更加合适。如果我们需要控制对某些资源的并发访问，<code>Semaphore</code>可能是最好的选择。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？&quot;&gt;&lt;a href=&quot;#新建-T1、T2、T3-三个线程，如何保证它们按顺序执行？&quot; class=&quot;headerlink&quot; title=&quot;新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="技术" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="JUC" scheme="https://kkwans.cn/categories/%E6%8A%80%E6%9C%AF/JUC/"/>
    
    
    <category term="八股" scheme="https://kkwans.cn/tags/%E5%85%AB%E8%82%A1/"/>
    
    <category term="多线程" scheme="https://kkwans.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="同步" scheme="https://kkwans.cn/tags/%E5%90%8C%E6%AD%A5/"/>
    
  </entry>
  
</feed>
